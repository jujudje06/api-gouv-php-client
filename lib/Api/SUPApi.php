<?php
/**
 * SUPApi
 * PHP version 5
 *
 * @category Class
 * @package  ApiGouv\Client
 * @author   Swagger Codegen team
 * @link     https://github.com/swagger-api/swagger-codegen
 */

/**
 * Module urbanisme (GpU)
 *
 * Le service d’interrogation du GPU permet d’obtenir des informations d’urbanisme intersectant une géométrie (ponctuelle ou surfacique).  Attention : les géométries passées en paramètre doivent comporter un nombre de points raisonnable.  Toutes les réponses sont au format GeoJSON et de type FeatureCollection. Toutes les requêtes du module GPU peuvent se faire en POST ou en GET.   Consultez la [documentation utilisateur](https://apicarto.ign.fr/api/doc/pdf/docUser_moduleUrbanisme.pdf) pour plus d’informations sur les paramètres d’appel disponibles et le format des résultats.  Exemple de géométrie: (référentiel EPSG:4326)    * Centre de Rennes:       `{\"type\": \"Point\",\"coordinates\":[-1.691634,48.104237]}`   * Parcelle:         `{\"type\":\"MultiPolygon\",\"coordinates\":[[[[-0.4781433,44.745308],[-0.4782708,44.74523],[-0.4783436,44.7451852],[-0.4783998,44.7451462],[-0.4784414,44.7451099],[-0.4784924,44.7450598],[-0.4785333,44.7450223],[-0.4785783,44.7449774],[-0.4786326,44.7449217],[-0.4786341,44.7449202],[-0.4795499,44.7457302],[-0.4789179,44.7461035],[-0.4781433,44.745308]]]]}`
 *
 * OpenAPI spec version: 1
 * 
 * Generated by: https://github.com/swagger-api/swagger-codegen.git
 * Swagger Codegen version: 2.4.39
 */

/**
 * NOTE: This class is auto generated by the swagger code generator program.
 * https://github.com/swagger-api/swagger-codegen
 * Do not edit the class manually.
 */

namespace ApiGouv\Client\Api;

use GuzzleHttp\Client;
use GuzzleHttp\ClientInterface;
use GuzzleHttp\Exception\RequestException;
use GuzzleHttp\Psr7\MultipartStream;
use GuzzleHttp\Psr7\Request;
use GuzzleHttp\RequestOptions;
use ApiGouv\Client\ApiException;
use ApiGouv\Client\Configuration;
use ApiGouv\Client\HeaderSelector;
use ApiGouv\Client\ObjectSerializer;

/**
 * SUPApi Class Doc Comment
 *
 * @category Class
 * @package  ApiGouv\Client
 * @author   Swagger Codegen team
 * @link     https://github.com/swagger-api/swagger-codegen
 */
class SUPApi
{
    /**
     * @var ClientInterface
     */
    protected $client;

    /**
     * @var Configuration
     */
    protected $config;

    /**
     * @var HeaderSelector
     */
    protected $headerSelector;

    /**
     * @param ClientInterface $client
     * @param Configuration   $config
     * @param HeaderSelector  $selector
     */
    public function __construct(
        ClientInterface $client = null,
        Configuration $config = null,
        HeaderSelector $selector = null
    ) {
        $this->client = $client ?: new Client();
        $this->config = $config ?: new Configuration();
        $this->headerSelector = $selector ?: new HeaderSelector();
    }

    /**
     * @return Configuration
     */
    public function getConfig()
    {
        return $this->config;
    }

    /**
     * Operation gpuActeSupGet
     *
     * Récupération des actes des servitudes d’utilité publique
     *
     * @param  string $partition Partition GPU du document (optional)
     *
     * @throws \ApiGouv\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \ApiGouv\Client\Model\FeatureCollection
     */
    public function gpuActeSupGet($partition = null)
    {
        list($response) = $this->gpuActeSupGetWithHttpInfo($partition);
        return $response;
    }

    /**
     * Operation gpuActeSupGetWithHttpInfo
     *
     * Récupération des actes des servitudes d’utilité publique
     *
     * @param  string $partition Partition GPU du document (optional)
     *
     * @throws \ApiGouv\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \ApiGouv\Client\Model\FeatureCollection, HTTP status code, HTTP response headers (array of strings)
     */
    public function gpuActeSupGetWithHttpInfo($partition = null)
    {
        $returnType = '\ApiGouv\Client\Model\FeatureCollection';
        $request = $this->gpuActeSupGetRequest($partition);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\ApiGouv\Client\Model\FeatureCollection',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation gpuActeSupGetAsync
     *
     * Récupération des actes des servitudes d’utilité publique
     *
     * @param  string $partition Partition GPU du document (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function gpuActeSupGetAsync($partition = null)
    {
        return $this->gpuActeSupGetAsyncWithHttpInfo($partition)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation gpuActeSupGetAsyncWithHttpInfo
     *
     * Récupération des actes des servitudes d’utilité publique
     *
     * @param  string $partition Partition GPU du document (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function gpuActeSupGetAsyncWithHttpInfo($partition = null)
    {
        $returnType = '\ApiGouv\Client\Model\FeatureCollection';
        $request = $this->gpuActeSupGetRequest($partition);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'gpuActeSupGet'
     *
     * @param  string $partition Partition GPU du document (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function gpuActeSupGetRequest($partition = null)
    {

        $resourcePath = '/gpu/acte-sup';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        if ($partition !== null) {
            $queryParams['partition'] = ObjectSerializer::toQueryValue($partition);
        }


        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                []
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            
            if($headers['Content-Type'] === 'application/json') {
                // \stdClass has no __toString(), so we should encode it manually
                if ($httpBody instanceof \stdClass) {
                    $httpBody = \GuzzleHttp\json_encode($httpBody);
                }
                // array has no __toString(), so we should encode it manually
                if(is_array($httpBody)) {
                    $httpBody = \GuzzleHttp\json_encode(ObjectSerializer::sanitizeForSerialization($httpBody));
                }
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\Query::build($formParams);
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\Query::build($queryParams);
        return new Request(
            'GET',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation gpuAssietteSupLGet
     *
     * Récupération des assiettes linéaires de servitudes d’utilité publique
     *
     * @param  string $geom Géométrie GeoJSON utilisée pour la recherche (optional)
     * @param  string $partition Partition GPU du document (optional)
     * @param  string $categorie Categorie (optional)
     *
     * @throws \ApiGouv\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \ApiGouv\Client\Model\FeatureCollection
     */
    public function gpuAssietteSupLGet($geom = null, $partition = null, $categorie = null)
    {
        list($response) = $this->gpuAssietteSupLGetWithHttpInfo($geom, $partition, $categorie);
        return $response;
    }

    /**
     * Operation gpuAssietteSupLGetWithHttpInfo
     *
     * Récupération des assiettes linéaires de servitudes d’utilité publique
     *
     * @param  string $geom Géométrie GeoJSON utilisée pour la recherche (optional)
     * @param  string $partition Partition GPU du document (optional)
     * @param  string $categorie Categorie (optional)
     *
     * @throws \ApiGouv\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \ApiGouv\Client\Model\FeatureCollection, HTTP status code, HTTP response headers (array of strings)
     */
    public function gpuAssietteSupLGetWithHttpInfo($geom = null, $partition = null, $categorie = null)
    {
        $returnType = '\ApiGouv\Client\Model\FeatureCollection';
        $request = $this->gpuAssietteSupLGetRequest($geom, $partition, $categorie);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\ApiGouv\Client\Model\FeatureCollection',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation gpuAssietteSupLGetAsync
     *
     * Récupération des assiettes linéaires de servitudes d’utilité publique
     *
     * @param  string $geom Géométrie GeoJSON utilisée pour la recherche (optional)
     * @param  string $partition Partition GPU du document (optional)
     * @param  string $categorie Categorie (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function gpuAssietteSupLGetAsync($geom = null, $partition = null, $categorie = null)
    {
        return $this->gpuAssietteSupLGetAsyncWithHttpInfo($geom, $partition, $categorie)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation gpuAssietteSupLGetAsyncWithHttpInfo
     *
     * Récupération des assiettes linéaires de servitudes d’utilité publique
     *
     * @param  string $geom Géométrie GeoJSON utilisée pour la recherche (optional)
     * @param  string $partition Partition GPU du document (optional)
     * @param  string $categorie Categorie (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function gpuAssietteSupLGetAsyncWithHttpInfo($geom = null, $partition = null, $categorie = null)
    {
        $returnType = '\ApiGouv\Client\Model\FeatureCollection';
        $request = $this->gpuAssietteSupLGetRequest($geom, $partition, $categorie);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'gpuAssietteSupLGet'
     *
     * @param  string $geom Géométrie GeoJSON utilisée pour la recherche (optional)
     * @param  string $partition Partition GPU du document (optional)
     * @param  string $categorie Categorie (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function gpuAssietteSupLGetRequest($geom = null, $partition = null, $categorie = null)
    {

        $resourcePath = '/gpu/assiette-sup-l';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        if ($geom !== null) {
            $queryParams['geom'] = ObjectSerializer::toQueryValue($geom);
        }
        // query params
        if ($partition !== null) {
            $queryParams['partition'] = ObjectSerializer::toQueryValue($partition);
        }
        // query params
        if ($categorie !== null) {
            $queryParams['categorie'] = ObjectSerializer::toQueryValue($categorie);
        }


        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                []
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            
            if($headers['Content-Type'] === 'application/json') {
                // \stdClass has no __toString(), so we should encode it manually
                if ($httpBody instanceof \stdClass) {
                    $httpBody = \GuzzleHttp\json_encode($httpBody);
                }
                // array has no __toString(), so we should encode it manually
                if(is_array($httpBody)) {
                    $httpBody = \GuzzleHttp\json_encode(ObjectSerializer::sanitizeForSerialization($httpBody));
                }
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\Query::build($formParams);
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\Query::build($queryParams);
        return new Request(
            'GET',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation gpuAssietteSupPGet
     *
     * Récupération des assiettes ponctuelles de servitudes d’utilité publique
     *
     * @param  string $geom Géométrie GeoJSON utilisée pour la recherche (optional)
     * @param  string $partition Partition GPU du document (optional)
     * @param  string $categorie Categorie (optional)
     *
     * @throws \ApiGouv\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \ApiGouv\Client\Model\FeatureCollection
     */
    public function gpuAssietteSupPGet($geom = null, $partition = null, $categorie = null)
    {
        list($response) = $this->gpuAssietteSupPGetWithHttpInfo($geom, $partition, $categorie);
        return $response;
    }

    /**
     * Operation gpuAssietteSupPGetWithHttpInfo
     *
     * Récupération des assiettes ponctuelles de servitudes d’utilité publique
     *
     * @param  string $geom Géométrie GeoJSON utilisée pour la recherche (optional)
     * @param  string $partition Partition GPU du document (optional)
     * @param  string $categorie Categorie (optional)
     *
     * @throws \ApiGouv\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \ApiGouv\Client\Model\FeatureCollection, HTTP status code, HTTP response headers (array of strings)
     */
    public function gpuAssietteSupPGetWithHttpInfo($geom = null, $partition = null, $categorie = null)
    {
        $returnType = '\ApiGouv\Client\Model\FeatureCollection';
        $request = $this->gpuAssietteSupPGetRequest($geom, $partition, $categorie);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\ApiGouv\Client\Model\FeatureCollection',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation gpuAssietteSupPGetAsync
     *
     * Récupération des assiettes ponctuelles de servitudes d’utilité publique
     *
     * @param  string $geom Géométrie GeoJSON utilisée pour la recherche (optional)
     * @param  string $partition Partition GPU du document (optional)
     * @param  string $categorie Categorie (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function gpuAssietteSupPGetAsync($geom = null, $partition = null, $categorie = null)
    {
        return $this->gpuAssietteSupPGetAsyncWithHttpInfo($geom, $partition, $categorie)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation gpuAssietteSupPGetAsyncWithHttpInfo
     *
     * Récupération des assiettes ponctuelles de servitudes d’utilité publique
     *
     * @param  string $geom Géométrie GeoJSON utilisée pour la recherche (optional)
     * @param  string $partition Partition GPU du document (optional)
     * @param  string $categorie Categorie (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function gpuAssietteSupPGetAsyncWithHttpInfo($geom = null, $partition = null, $categorie = null)
    {
        $returnType = '\ApiGouv\Client\Model\FeatureCollection';
        $request = $this->gpuAssietteSupPGetRequest($geom, $partition, $categorie);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'gpuAssietteSupPGet'
     *
     * @param  string $geom Géométrie GeoJSON utilisée pour la recherche (optional)
     * @param  string $partition Partition GPU du document (optional)
     * @param  string $categorie Categorie (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function gpuAssietteSupPGetRequest($geom = null, $partition = null, $categorie = null)
    {

        $resourcePath = '/gpu/assiette-sup-p';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        if ($geom !== null) {
            $queryParams['geom'] = ObjectSerializer::toQueryValue($geom);
        }
        // query params
        if ($partition !== null) {
            $queryParams['partition'] = ObjectSerializer::toQueryValue($partition);
        }
        // query params
        if ($categorie !== null) {
            $queryParams['categorie'] = ObjectSerializer::toQueryValue($categorie);
        }


        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                []
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            
            if($headers['Content-Type'] === 'application/json') {
                // \stdClass has no __toString(), so we should encode it manually
                if ($httpBody instanceof \stdClass) {
                    $httpBody = \GuzzleHttp\json_encode($httpBody);
                }
                // array has no __toString(), so we should encode it manually
                if(is_array($httpBody)) {
                    $httpBody = \GuzzleHttp\json_encode(ObjectSerializer::sanitizeForSerialization($httpBody));
                }
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\Query::build($formParams);
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\Query::build($queryParams);
        return new Request(
            'GET',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation gpuAssietteSupSGet
     *
     * Récupération des assiettes surfaciques de servitudes d’utilité publique
     *
     * @param  string $geom Géométrie GeoJSON utilisée pour la recherche (optional)
     * @param  string $partition Partition GPU du document (optional)
     * @param  string $categorie Categorie (optional)
     *
     * @throws \ApiGouv\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \ApiGouv\Client\Model\FeatureCollection
     */
    public function gpuAssietteSupSGet($geom = null, $partition = null, $categorie = null)
    {
        list($response) = $this->gpuAssietteSupSGetWithHttpInfo($geom, $partition, $categorie);
        return $response;
    }

    /**
     * Operation gpuAssietteSupSGetWithHttpInfo
     *
     * Récupération des assiettes surfaciques de servitudes d’utilité publique
     *
     * @param  string $geom Géométrie GeoJSON utilisée pour la recherche (optional)
     * @param  string $partition Partition GPU du document (optional)
     * @param  string $categorie Categorie (optional)
     *
     * @throws \ApiGouv\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \ApiGouv\Client\Model\FeatureCollection, HTTP status code, HTTP response headers (array of strings)
     */
    public function gpuAssietteSupSGetWithHttpInfo($geom = null, $partition = null, $categorie = null)
    {
        $returnType = '\ApiGouv\Client\Model\FeatureCollection';
        $request = $this->gpuAssietteSupSGetRequest($geom, $partition, $categorie);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\ApiGouv\Client\Model\FeatureCollection',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation gpuAssietteSupSGetAsync
     *
     * Récupération des assiettes surfaciques de servitudes d’utilité publique
     *
     * @param  string $geom Géométrie GeoJSON utilisée pour la recherche (optional)
     * @param  string $partition Partition GPU du document (optional)
     * @param  string $categorie Categorie (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function gpuAssietteSupSGetAsync($geom = null, $partition = null, $categorie = null)
    {
        return $this->gpuAssietteSupSGetAsyncWithHttpInfo($geom, $partition, $categorie)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation gpuAssietteSupSGetAsyncWithHttpInfo
     *
     * Récupération des assiettes surfaciques de servitudes d’utilité publique
     *
     * @param  string $geom Géométrie GeoJSON utilisée pour la recherche (optional)
     * @param  string $partition Partition GPU du document (optional)
     * @param  string $categorie Categorie (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function gpuAssietteSupSGetAsyncWithHttpInfo($geom = null, $partition = null, $categorie = null)
    {
        $returnType = '\ApiGouv\Client\Model\FeatureCollection';
        $request = $this->gpuAssietteSupSGetRequest($geom, $partition, $categorie);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'gpuAssietteSupSGet'
     *
     * @param  string $geom Géométrie GeoJSON utilisée pour la recherche (optional)
     * @param  string $partition Partition GPU du document (optional)
     * @param  string $categorie Categorie (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function gpuAssietteSupSGetRequest($geom = null, $partition = null, $categorie = null)
    {

        $resourcePath = '/gpu/assiette-sup-s';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        if ($geom !== null) {
            $queryParams['geom'] = ObjectSerializer::toQueryValue($geom);
        }
        // query params
        if ($partition !== null) {
            $queryParams['partition'] = ObjectSerializer::toQueryValue($partition);
        }
        // query params
        if ($categorie !== null) {
            $queryParams['categorie'] = ObjectSerializer::toQueryValue($categorie);
        }


        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                []
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            
            if($headers['Content-Type'] === 'application/json') {
                // \stdClass has no __toString(), so we should encode it manually
                if ($httpBody instanceof \stdClass) {
                    $httpBody = \GuzzleHttp\json_encode($httpBody);
                }
                // array has no __toString(), so we should encode it manually
                if(is_array($httpBody)) {
                    $httpBody = \GuzzleHttp\json_encode(ObjectSerializer::sanitizeForSerialization($httpBody));
                }
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\Query::build($formParams);
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\Query::build($queryParams);
        return new Request(
            'GET',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation gpuGenerateurSupLGet
     *
     * Récupération des générateurs linéaires des servitudes d’utilité publique
     *
     * @param  string $geom Géométrie GeoJSON utilisée pour la recherche (optional)
     * @param  string $partition Partition GPU du document au format (optional)
     * @param  string $categorie Categorie (optional)
     *
     * @throws \ApiGouv\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \ApiGouv\Client\Model\FeatureCollection
     */
    public function gpuGenerateurSupLGet($geom = null, $partition = null, $categorie = null)
    {
        list($response) = $this->gpuGenerateurSupLGetWithHttpInfo($geom, $partition, $categorie);
        return $response;
    }

    /**
     * Operation gpuGenerateurSupLGetWithHttpInfo
     *
     * Récupération des générateurs linéaires des servitudes d’utilité publique
     *
     * @param  string $geom Géométrie GeoJSON utilisée pour la recherche (optional)
     * @param  string $partition Partition GPU du document au format (optional)
     * @param  string $categorie Categorie (optional)
     *
     * @throws \ApiGouv\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \ApiGouv\Client\Model\FeatureCollection, HTTP status code, HTTP response headers (array of strings)
     */
    public function gpuGenerateurSupLGetWithHttpInfo($geom = null, $partition = null, $categorie = null)
    {
        $returnType = '\ApiGouv\Client\Model\FeatureCollection';
        $request = $this->gpuGenerateurSupLGetRequest($geom, $partition, $categorie);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\ApiGouv\Client\Model\FeatureCollection',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation gpuGenerateurSupLGetAsync
     *
     * Récupération des générateurs linéaires des servitudes d’utilité publique
     *
     * @param  string $geom Géométrie GeoJSON utilisée pour la recherche (optional)
     * @param  string $partition Partition GPU du document au format (optional)
     * @param  string $categorie Categorie (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function gpuGenerateurSupLGetAsync($geom = null, $partition = null, $categorie = null)
    {
        return $this->gpuGenerateurSupLGetAsyncWithHttpInfo($geom, $partition, $categorie)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation gpuGenerateurSupLGetAsyncWithHttpInfo
     *
     * Récupération des générateurs linéaires des servitudes d’utilité publique
     *
     * @param  string $geom Géométrie GeoJSON utilisée pour la recherche (optional)
     * @param  string $partition Partition GPU du document au format (optional)
     * @param  string $categorie Categorie (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function gpuGenerateurSupLGetAsyncWithHttpInfo($geom = null, $partition = null, $categorie = null)
    {
        $returnType = '\ApiGouv\Client\Model\FeatureCollection';
        $request = $this->gpuGenerateurSupLGetRequest($geom, $partition, $categorie);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'gpuGenerateurSupLGet'
     *
     * @param  string $geom Géométrie GeoJSON utilisée pour la recherche (optional)
     * @param  string $partition Partition GPU du document au format (optional)
     * @param  string $categorie Categorie (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function gpuGenerateurSupLGetRequest($geom = null, $partition = null, $categorie = null)
    {

        $resourcePath = '/gpu/generateur-sup-l';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        if ($geom !== null) {
            $queryParams['geom'] = ObjectSerializer::toQueryValue($geom);
        }
        // query params
        if ($partition !== null) {
            $queryParams['partition'] = ObjectSerializer::toQueryValue($partition);
        }
        // query params
        if ($categorie !== null) {
            $queryParams['categorie'] = ObjectSerializer::toQueryValue($categorie);
        }


        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                []
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            
            if($headers['Content-Type'] === 'application/json') {
                // \stdClass has no __toString(), so we should encode it manually
                if ($httpBody instanceof \stdClass) {
                    $httpBody = \GuzzleHttp\json_encode($httpBody);
                }
                // array has no __toString(), so we should encode it manually
                if(is_array($httpBody)) {
                    $httpBody = \GuzzleHttp\json_encode(ObjectSerializer::sanitizeForSerialization($httpBody));
                }
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\Query::build($formParams);
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\Query::build($queryParams);
        return new Request(
            'GET',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation gpuGenerateurSupPGet
     *
     * Récupération des générateurs ponctuels des servitudes d’utilité publique
     *
     * @param  string $geom Géométrie GeoJSON utilisée pour la recherche (optional)
     * @param  string $partition Partition GPU du document au format &lt;DU/PSMV&gt;_&lt;INSEE/SIREN&gt; (optional)
     * @param  string $categorie Categorie (optional)
     *
     * @throws \ApiGouv\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \ApiGouv\Client\Model\FeatureCollection
     */
    public function gpuGenerateurSupPGet($geom = null, $partition = null, $categorie = null)
    {
        list($response) = $this->gpuGenerateurSupPGetWithHttpInfo($geom, $partition, $categorie);
        return $response;
    }

    /**
     * Operation gpuGenerateurSupPGetWithHttpInfo
     *
     * Récupération des générateurs ponctuels des servitudes d’utilité publique
     *
     * @param  string $geom Géométrie GeoJSON utilisée pour la recherche (optional)
     * @param  string $partition Partition GPU du document au format &lt;DU/PSMV&gt;_&lt;INSEE/SIREN&gt; (optional)
     * @param  string $categorie Categorie (optional)
     *
     * @throws \ApiGouv\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \ApiGouv\Client\Model\FeatureCollection, HTTP status code, HTTP response headers (array of strings)
     */
    public function gpuGenerateurSupPGetWithHttpInfo($geom = null, $partition = null, $categorie = null)
    {
        $returnType = '\ApiGouv\Client\Model\FeatureCollection';
        $request = $this->gpuGenerateurSupPGetRequest($geom, $partition, $categorie);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\ApiGouv\Client\Model\FeatureCollection',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation gpuGenerateurSupPGetAsync
     *
     * Récupération des générateurs ponctuels des servitudes d’utilité publique
     *
     * @param  string $geom Géométrie GeoJSON utilisée pour la recherche (optional)
     * @param  string $partition Partition GPU du document au format &lt;DU/PSMV&gt;_&lt;INSEE/SIREN&gt; (optional)
     * @param  string $categorie Categorie (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function gpuGenerateurSupPGetAsync($geom = null, $partition = null, $categorie = null)
    {
        return $this->gpuGenerateurSupPGetAsyncWithHttpInfo($geom, $partition, $categorie)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation gpuGenerateurSupPGetAsyncWithHttpInfo
     *
     * Récupération des générateurs ponctuels des servitudes d’utilité publique
     *
     * @param  string $geom Géométrie GeoJSON utilisée pour la recherche (optional)
     * @param  string $partition Partition GPU du document au format &lt;DU/PSMV&gt;_&lt;INSEE/SIREN&gt; (optional)
     * @param  string $categorie Categorie (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function gpuGenerateurSupPGetAsyncWithHttpInfo($geom = null, $partition = null, $categorie = null)
    {
        $returnType = '\ApiGouv\Client\Model\FeatureCollection';
        $request = $this->gpuGenerateurSupPGetRequest($geom, $partition, $categorie);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'gpuGenerateurSupPGet'
     *
     * @param  string $geom Géométrie GeoJSON utilisée pour la recherche (optional)
     * @param  string $partition Partition GPU du document au format &lt;DU/PSMV&gt;_&lt;INSEE/SIREN&gt; (optional)
     * @param  string $categorie Categorie (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function gpuGenerateurSupPGetRequest($geom = null, $partition = null, $categorie = null)
    {

        $resourcePath = '/gpu/generateur-sup-p';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        if ($geom !== null) {
            $queryParams['geom'] = ObjectSerializer::toQueryValue($geom);
        }
        // query params
        if ($partition !== null) {
            $queryParams['partition'] = ObjectSerializer::toQueryValue($partition);
        }
        // query params
        if ($categorie !== null) {
            $queryParams['categorie'] = ObjectSerializer::toQueryValue($categorie);
        }


        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                []
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            
            if($headers['Content-Type'] === 'application/json') {
                // \stdClass has no __toString(), so we should encode it manually
                if ($httpBody instanceof \stdClass) {
                    $httpBody = \GuzzleHttp\json_encode($httpBody);
                }
                // array has no __toString(), so we should encode it manually
                if(is_array($httpBody)) {
                    $httpBody = \GuzzleHttp\json_encode(ObjectSerializer::sanitizeForSerialization($httpBody));
                }
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\Query::build($formParams);
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\Query::build($queryParams);
        return new Request(
            'GET',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation gpuGenerateurSupSGet
     *
     * Récupération des générateurs surfaciques des servitudes d’utilité publique
     *
     * @param  string $geom Géométrie GeoJSON utilisée pour la recherche (optional)
     * @param  string $partition Partition GPU du document (optional)
     * @param  string $categorie Categorie (optional)
     *
     * @throws \ApiGouv\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \ApiGouv\Client\Model\FeatureCollection
     */
    public function gpuGenerateurSupSGet($geom = null, $partition = null, $categorie = null)
    {
        list($response) = $this->gpuGenerateurSupSGetWithHttpInfo($geom, $partition, $categorie);
        return $response;
    }

    /**
     * Operation gpuGenerateurSupSGetWithHttpInfo
     *
     * Récupération des générateurs surfaciques des servitudes d’utilité publique
     *
     * @param  string $geom Géométrie GeoJSON utilisée pour la recherche (optional)
     * @param  string $partition Partition GPU du document (optional)
     * @param  string $categorie Categorie (optional)
     *
     * @throws \ApiGouv\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \ApiGouv\Client\Model\FeatureCollection, HTTP status code, HTTP response headers (array of strings)
     */
    public function gpuGenerateurSupSGetWithHttpInfo($geom = null, $partition = null, $categorie = null)
    {
        $returnType = '\ApiGouv\Client\Model\FeatureCollection';
        $request = $this->gpuGenerateurSupSGetRequest($geom, $partition, $categorie);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\ApiGouv\Client\Model\FeatureCollection',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation gpuGenerateurSupSGetAsync
     *
     * Récupération des générateurs surfaciques des servitudes d’utilité publique
     *
     * @param  string $geom Géométrie GeoJSON utilisée pour la recherche (optional)
     * @param  string $partition Partition GPU du document (optional)
     * @param  string $categorie Categorie (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function gpuGenerateurSupSGetAsync($geom = null, $partition = null, $categorie = null)
    {
        return $this->gpuGenerateurSupSGetAsyncWithHttpInfo($geom, $partition, $categorie)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation gpuGenerateurSupSGetAsyncWithHttpInfo
     *
     * Récupération des générateurs surfaciques des servitudes d’utilité publique
     *
     * @param  string $geom Géométrie GeoJSON utilisée pour la recherche (optional)
     * @param  string $partition Partition GPU du document (optional)
     * @param  string $categorie Categorie (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function gpuGenerateurSupSGetAsyncWithHttpInfo($geom = null, $partition = null, $categorie = null)
    {
        $returnType = '\ApiGouv\Client\Model\FeatureCollection';
        $request = $this->gpuGenerateurSupSGetRequest($geom, $partition, $categorie);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'gpuGenerateurSupSGet'
     *
     * @param  string $geom Géométrie GeoJSON utilisée pour la recherche (optional)
     * @param  string $partition Partition GPU du document (optional)
     * @param  string $categorie Categorie (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function gpuGenerateurSupSGetRequest($geom = null, $partition = null, $categorie = null)
    {

        $resourcePath = '/gpu/generateur-sup-s';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        if ($geom !== null) {
            $queryParams['geom'] = ObjectSerializer::toQueryValue($geom);
        }
        // query params
        if ($partition !== null) {
            $queryParams['partition'] = ObjectSerializer::toQueryValue($partition);
        }
        // query params
        if ($categorie !== null) {
            $queryParams['categorie'] = ObjectSerializer::toQueryValue($categorie);
        }


        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                []
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            
            if($headers['Content-Type'] === 'application/json') {
                // \stdClass has no __toString(), so we should encode it manually
                if ($httpBody instanceof \stdClass) {
                    $httpBody = \GuzzleHttp\json_encode($httpBody);
                }
                // array has no __toString(), so we should encode it manually
                if(is_array($httpBody)) {
                    $httpBody = \GuzzleHttp\json_encode(ObjectSerializer::sanitizeForSerialization($httpBody));
                }
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\Query::build($formParams);
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\Query::build($queryParams);
        return new Request(
            'GET',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Create http client option
     *
     * @throws \RuntimeException on file opening failure
     * @return array of http client options
     */
    protected function createHttpClientOption()
    {
        $options = [];
        if ($this->config->getDebug()) {
            $options[RequestOptions::DEBUG] = fopen($this->config->getDebugFile(), 'a');
            if (!$options[RequestOptions::DEBUG]) {
                throw new \RuntimeException('Failed to open the debug file: ' . $this->config->getDebugFile());
            }
        }

        return $options;
    }
}
