<?php
/**
 * DocumentsDurbanismePLUPOSCCPSMVApi
 * PHP version 5
 *
 * @category Class
 * @package  ApiGouv\Client
 * @author   Swagger Codegen team
 * @link     https://github.com/swagger-api/swagger-codegen
 */

/**
 * Module urbanisme (GpU)
 *
 * Le service d’interrogation du GPU permet d’obtenir des informations d’urbanisme intersectant une géométrie (ponctuelle ou surfacique).  Attention : les géométries passées en paramètre doivent comporter un nombre de points raisonnable.  Toutes les réponses sont au format GeoJSON et de type FeatureCollection. Toutes les requêtes du module GPU peuvent se faire en POST ou en GET.   Consultez la [documentation utilisateur](https://apicarto.ign.fr/api/doc/pdf/docUser_moduleUrbanisme.pdf) pour plus d’informations sur les paramètres d’appel disponibles et le format des résultats.  Exemple de géométrie: (référentiel EPSG:4326)    * Centre de Rennes:       `{\"type\": \"Point\",\"coordinates\":[-1.691634,48.104237]}`   * Parcelle:         `{\"type\":\"MultiPolygon\",\"coordinates\":[[[[-0.4781433,44.745308],[-0.4782708,44.74523],[-0.4783436,44.7451852],[-0.4783998,44.7451462],[-0.4784414,44.7451099],[-0.4784924,44.7450598],[-0.4785333,44.7450223],[-0.4785783,44.7449774],[-0.4786326,44.7449217],[-0.4786341,44.7449202],[-0.4795499,44.7457302],[-0.4789179,44.7461035],[-0.4781433,44.745308]]]]}`
 *
 * OpenAPI spec version: 1
 * 
 * Generated by: https://github.com/swagger-api/swagger-codegen.git
 * Swagger Codegen version: 2.4.39
 */

/**
 * NOTE: This class is auto generated by the swagger code generator program.
 * https://github.com/swagger-api/swagger-codegen
 * Do not edit the class manually.
 */

namespace ApiGouv\Client\Api;

use GuzzleHttp\Client;
use GuzzleHttp\ClientInterface;
use GuzzleHttp\Exception\RequestException;
use GuzzleHttp\Psr7\MultipartStream;
use GuzzleHttp\Psr7\Request;
use GuzzleHttp\RequestOptions;
use ApiGouv\Client\ApiException;
use ApiGouv\Client\Configuration;
use ApiGouv\Client\HeaderSelector;
use ApiGouv\Client\ObjectSerializer;

/**
 * DocumentsDurbanismePLUPOSCCPSMVApi Class Doc Comment
 *
 * @category Class
 * @package  ApiGouv\Client
 * @author   Swagger Codegen team
 * @link     https://github.com/swagger-api/swagger-codegen
 */
class DocumentsDurbanismePLUPOSCCPSMVApi
{
    /**
     * @var ClientInterface
     */
    protected $client;

    /**
     * @var Configuration
     */
    protected $config;

    /**
     * @var HeaderSelector
     */
    protected $headerSelector;

    /**
     * @param ClientInterface $client
     * @param Configuration   $config
     * @param HeaderSelector  $selector
     */
    public function __construct(
        ClientInterface $client = null,
        Configuration $config = null,
        HeaderSelector $selector = null
    ) {
        $this->client = $client ?: new Client();
        $this->config = $config ?: new Configuration();
        $this->headerSelector = $selector ?: new HeaderSelector();
    }

    /**
     * @return Configuration
     */
    public function getConfig()
    {
        return $this->config;
    }

    /**
     * Operation gpuDocumentGet
     *
     * Récupération de l'emprise d'un document
     *
     * @param  string $geom Géométrie GeoJSON utilisée pour la recherche (optional)
     * @param  string $partition Partition GPU du document au format &lt;DU/PSMV&gt;_&lt;INSEE/SIREN&gt; (optional)
     *
     * @throws \ApiGouv\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \ApiGouv\Client\Model\FeatureCollection
     */
    public function gpuDocumentGet($geom = null, $partition = null)
    {
        list($response) = $this->gpuDocumentGetWithHttpInfo($geom, $partition);
        return $response;
    }

    /**
     * Operation gpuDocumentGetWithHttpInfo
     *
     * Récupération de l'emprise d'un document
     *
     * @param  string $geom Géométrie GeoJSON utilisée pour la recherche (optional)
     * @param  string $partition Partition GPU du document au format &lt;DU/PSMV&gt;_&lt;INSEE/SIREN&gt; (optional)
     *
     * @throws \ApiGouv\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \ApiGouv\Client\Model\FeatureCollection, HTTP status code, HTTP response headers (array of strings)
     */
    public function gpuDocumentGetWithHttpInfo($geom = null, $partition = null)
    {
        $returnType = '\ApiGouv\Client\Model\FeatureCollection';
        $request = $this->gpuDocumentGetRequest($geom, $partition);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\ApiGouv\Client\Model\FeatureCollection',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation gpuDocumentGetAsync
     *
     * Récupération de l'emprise d'un document
     *
     * @param  string $geom Géométrie GeoJSON utilisée pour la recherche (optional)
     * @param  string $partition Partition GPU du document au format &lt;DU/PSMV&gt;_&lt;INSEE/SIREN&gt; (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function gpuDocumentGetAsync($geom = null, $partition = null)
    {
        return $this->gpuDocumentGetAsyncWithHttpInfo($geom, $partition)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation gpuDocumentGetAsyncWithHttpInfo
     *
     * Récupération de l'emprise d'un document
     *
     * @param  string $geom Géométrie GeoJSON utilisée pour la recherche (optional)
     * @param  string $partition Partition GPU du document au format &lt;DU/PSMV&gt;_&lt;INSEE/SIREN&gt; (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function gpuDocumentGetAsyncWithHttpInfo($geom = null, $partition = null)
    {
        $returnType = '\ApiGouv\Client\Model\FeatureCollection';
        $request = $this->gpuDocumentGetRequest($geom, $partition);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'gpuDocumentGet'
     *
     * @param  string $geom Géométrie GeoJSON utilisée pour la recherche (optional)
     * @param  string $partition Partition GPU du document au format &lt;DU/PSMV&gt;_&lt;INSEE/SIREN&gt; (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function gpuDocumentGetRequest($geom = null, $partition = null)
    {

        $resourcePath = '/gpu/document';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        if ($geom !== null) {
            $queryParams['geom'] = ObjectSerializer::toQueryValue($geom);
        }
        // query params
        if ($partition !== null) {
            $queryParams['partition'] = ObjectSerializer::toQueryValue($partition);
        }


        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                []
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            
            if($headers['Content-Type'] === 'application/json') {
                // \stdClass has no __toString(), so we should encode it manually
                if ($httpBody instanceof \stdClass) {
                    $httpBody = \GuzzleHttp\json_encode($httpBody);
                }
                // array has no __toString(), so we should encode it manually
                if(is_array($httpBody)) {
                    $httpBody = \GuzzleHttp\json_encode(ObjectSerializer::sanitizeForSerialization($httpBody));
                }
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\Query::build($formParams);
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\Query::build($queryParams);
        return new Request(
            'GET',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation gpuInfoLinGet
     *
     * Récupération des informations linéaires d’un document d’urbanisme
     *
     * @param  string $geom Géométrie GeoJSON utilisée pour la recherche (optional)
     * @param  string $partition Partition GPU du document au format &lt;DU/PSMV&gt;_&lt;INSEE/SIREN&gt; (optional)
     *
     * @throws \ApiGouv\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \ApiGouv\Client\Model\FeatureCollection
     */
    public function gpuInfoLinGet($geom = null, $partition = null)
    {
        list($response) = $this->gpuInfoLinGetWithHttpInfo($geom, $partition);
        return $response;
    }

    /**
     * Operation gpuInfoLinGetWithHttpInfo
     *
     * Récupération des informations linéaires d’un document d’urbanisme
     *
     * @param  string $geom Géométrie GeoJSON utilisée pour la recherche (optional)
     * @param  string $partition Partition GPU du document au format &lt;DU/PSMV&gt;_&lt;INSEE/SIREN&gt; (optional)
     *
     * @throws \ApiGouv\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \ApiGouv\Client\Model\FeatureCollection, HTTP status code, HTTP response headers (array of strings)
     */
    public function gpuInfoLinGetWithHttpInfo($geom = null, $partition = null)
    {
        $returnType = '\ApiGouv\Client\Model\FeatureCollection';
        $request = $this->gpuInfoLinGetRequest($geom, $partition);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\ApiGouv\Client\Model\FeatureCollection',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation gpuInfoLinGetAsync
     *
     * Récupération des informations linéaires d’un document d’urbanisme
     *
     * @param  string $geom Géométrie GeoJSON utilisée pour la recherche (optional)
     * @param  string $partition Partition GPU du document au format &lt;DU/PSMV&gt;_&lt;INSEE/SIREN&gt; (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function gpuInfoLinGetAsync($geom = null, $partition = null)
    {
        return $this->gpuInfoLinGetAsyncWithHttpInfo($geom, $partition)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation gpuInfoLinGetAsyncWithHttpInfo
     *
     * Récupération des informations linéaires d’un document d’urbanisme
     *
     * @param  string $geom Géométrie GeoJSON utilisée pour la recherche (optional)
     * @param  string $partition Partition GPU du document au format &lt;DU/PSMV&gt;_&lt;INSEE/SIREN&gt; (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function gpuInfoLinGetAsyncWithHttpInfo($geom = null, $partition = null)
    {
        $returnType = '\ApiGouv\Client\Model\FeatureCollection';
        $request = $this->gpuInfoLinGetRequest($geom, $partition);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'gpuInfoLinGet'
     *
     * @param  string $geom Géométrie GeoJSON utilisée pour la recherche (optional)
     * @param  string $partition Partition GPU du document au format &lt;DU/PSMV&gt;_&lt;INSEE/SIREN&gt; (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function gpuInfoLinGetRequest($geom = null, $partition = null)
    {

        $resourcePath = '/gpu/info-lin';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        if ($geom !== null) {
            $queryParams['geom'] = ObjectSerializer::toQueryValue($geom);
        }
        // query params
        if ($partition !== null) {
            $queryParams['partition'] = ObjectSerializer::toQueryValue($partition);
        }


        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                []
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            
            if($headers['Content-Type'] === 'application/json') {
                // \stdClass has no __toString(), so we should encode it manually
                if ($httpBody instanceof \stdClass) {
                    $httpBody = \GuzzleHttp\json_encode($httpBody);
                }
                // array has no __toString(), so we should encode it manually
                if(is_array($httpBody)) {
                    $httpBody = \GuzzleHttp\json_encode(ObjectSerializer::sanitizeForSerialization($httpBody));
                }
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\Query::build($formParams);
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\Query::build($queryParams);
        return new Request(
            'GET',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation gpuInfoPctGet
     *
     * Récupération des informations ponctuelles d’un document d’urbanisme
     *
     * @param  string $geom Géométrie GeoJSON utilisée pour la recherche (optional)
     * @param  string $partition Partition GPU du document au format &lt;DU/PSMV&gt;_&lt;INSEE/SIREN&gt; (optional)
     *
     * @throws \ApiGouv\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \ApiGouv\Client\Model\FeatureCollection
     */
    public function gpuInfoPctGet($geom = null, $partition = null)
    {
        list($response) = $this->gpuInfoPctGetWithHttpInfo($geom, $partition);
        return $response;
    }

    /**
     * Operation gpuInfoPctGetWithHttpInfo
     *
     * Récupération des informations ponctuelles d’un document d’urbanisme
     *
     * @param  string $geom Géométrie GeoJSON utilisée pour la recherche (optional)
     * @param  string $partition Partition GPU du document au format &lt;DU/PSMV&gt;_&lt;INSEE/SIREN&gt; (optional)
     *
     * @throws \ApiGouv\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \ApiGouv\Client\Model\FeatureCollection, HTTP status code, HTTP response headers (array of strings)
     */
    public function gpuInfoPctGetWithHttpInfo($geom = null, $partition = null)
    {
        $returnType = '\ApiGouv\Client\Model\FeatureCollection';
        $request = $this->gpuInfoPctGetRequest($geom, $partition);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\ApiGouv\Client\Model\FeatureCollection',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation gpuInfoPctGetAsync
     *
     * Récupération des informations ponctuelles d’un document d’urbanisme
     *
     * @param  string $geom Géométrie GeoJSON utilisée pour la recherche (optional)
     * @param  string $partition Partition GPU du document au format &lt;DU/PSMV&gt;_&lt;INSEE/SIREN&gt; (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function gpuInfoPctGetAsync($geom = null, $partition = null)
    {
        return $this->gpuInfoPctGetAsyncWithHttpInfo($geom, $partition)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation gpuInfoPctGetAsyncWithHttpInfo
     *
     * Récupération des informations ponctuelles d’un document d’urbanisme
     *
     * @param  string $geom Géométrie GeoJSON utilisée pour la recherche (optional)
     * @param  string $partition Partition GPU du document au format &lt;DU/PSMV&gt;_&lt;INSEE/SIREN&gt; (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function gpuInfoPctGetAsyncWithHttpInfo($geom = null, $partition = null)
    {
        $returnType = '\ApiGouv\Client\Model\FeatureCollection';
        $request = $this->gpuInfoPctGetRequest($geom, $partition);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'gpuInfoPctGet'
     *
     * @param  string $geom Géométrie GeoJSON utilisée pour la recherche (optional)
     * @param  string $partition Partition GPU du document au format &lt;DU/PSMV&gt;_&lt;INSEE/SIREN&gt; (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function gpuInfoPctGetRequest($geom = null, $partition = null)
    {

        $resourcePath = '/gpu/info-pct';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        if ($geom !== null) {
            $queryParams['geom'] = ObjectSerializer::toQueryValue($geom);
        }
        // query params
        if ($partition !== null) {
            $queryParams['partition'] = ObjectSerializer::toQueryValue($partition);
        }


        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                []
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            
            if($headers['Content-Type'] === 'application/json') {
                // \stdClass has no __toString(), so we should encode it manually
                if ($httpBody instanceof \stdClass) {
                    $httpBody = \GuzzleHttp\json_encode($httpBody);
                }
                // array has no __toString(), so we should encode it manually
                if(is_array($httpBody)) {
                    $httpBody = \GuzzleHttp\json_encode(ObjectSerializer::sanitizeForSerialization($httpBody));
                }
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\Query::build($formParams);
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\Query::build($queryParams);
        return new Request(
            'GET',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation gpuInfoSurfGet
     *
     * Récupération des informations surfaciques d’un document d’urbanisme
     *
     * @param  string $geom Géométrie GeoJSON utilisée pour la recherche (optional)
     * @param  string $partition Partition GPU du document au format &lt;DU/PSMV&gt;_&lt;INSEE/SIREN&gt; (optional)
     *
     * @throws \ApiGouv\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \ApiGouv\Client\Model\FeatureCollection
     */
    public function gpuInfoSurfGet($geom = null, $partition = null)
    {
        list($response) = $this->gpuInfoSurfGetWithHttpInfo($geom, $partition);
        return $response;
    }

    /**
     * Operation gpuInfoSurfGetWithHttpInfo
     *
     * Récupération des informations surfaciques d’un document d’urbanisme
     *
     * @param  string $geom Géométrie GeoJSON utilisée pour la recherche (optional)
     * @param  string $partition Partition GPU du document au format &lt;DU/PSMV&gt;_&lt;INSEE/SIREN&gt; (optional)
     *
     * @throws \ApiGouv\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \ApiGouv\Client\Model\FeatureCollection, HTTP status code, HTTP response headers (array of strings)
     */
    public function gpuInfoSurfGetWithHttpInfo($geom = null, $partition = null)
    {
        $returnType = '\ApiGouv\Client\Model\FeatureCollection';
        $request = $this->gpuInfoSurfGetRequest($geom, $partition);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\ApiGouv\Client\Model\FeatureCollection',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation gpuInfoSurfGetAsync
     *
     * Récupération des informations surfaciques d’un document d’urbanisme
     *
     * @param  string $geom Géométrie GeoJSON utilisée pour la recherche (optional)
     * @param  string $partition Partition GPU du document au format &lt;DU/PSMV&gt;_&lt;INSEE/SIREN&gt; (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function gpuInfoSurfGetAsync($geom = null, $partition = null)
    {
        return $this->gpuInfoSurfGetAsyncWithHttpInfo($geom, $partition)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation gpuInfoSurfGetAsyncWithHttpInfo
     *
     * Récupération des informations surfaciques d’un document d’urbanisme
     *
     * @param  string $geom Géométrie GeoJSON utilisée pour la recherche (optional)
     * @param  string $partition Partition GPU du document au format &lt;DU/PSMV&gt;_&lt;INSEE/SIREN&gt; (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function gpuInfoSurfGetAsyncWithHttpInfo($geom = null, $partition = null)
    {
        $returnType = '\ApiGouv\Client\Model\FeatureCollection';
        $request = $this->gpuInfoSurfGetRequest($geom, $partition);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'gpuInfoSurfGet'
     *
     * @param  string $geom Géométrie GeoJSON utilisée pour la recherche (optional)
     * @param  string $partition Partition GPU du document au format &lt;DU/PSMV&gt;_&lt;INSEE/SIREN&gt; (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function gpuInfoSurfGetRequest($geom = null, $partition = null)
    {

        $resourcePath = '/gpu/info-surf';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        if ($geom !== null) {
            $queryParams['geom'] = ObjectSerializer::toQueryValue($geom);
        }
        // query params
        if ($partition !== null) {
            $queryParams['partition'] = ObjectSerializer::toQueryValue($partition);
        }


        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                []
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            
            if($headers['Content-Type'] === 'application/json') {
                // \stdClass has no __toString(), so we should encode it manually
                if ($httpBody instanceof \stdClass) {
                    $httpBody = \GuzzleHttp\json_encode($httpBody);
                }
                // array has no __toString(), so we should encode it manually
                if(is_array($httpBody)) {
                    $httpBody = \GuzzleHttp\json_encode(ObjectSerializer::sanitizeForSerialization($httpBody));
                }
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\Query::build($formParams);
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\Query::build($queryParams);
        return new Request(
            'GET',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation gpuPrescriptionLinGet
     *
     * Récupération des prescriptions linéaires d’un document d’urbanisme
     *
     * @param  string $geom Géométrie GeoJSON utilisée pour la recherche (optional)
     * @param  string $partition Partition GPU du document au format &lt;DU/PSMV&gt;_&lt;INSEE/SIREN&gt; (optional)
     *
     * @throws \ApiGouv\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \ApiGouv\Client\Model\FeatureCollection
     */
    public function gpuPrescriptionLinGet($geom = null, $partition = null)
    {
        list($response) = $this->gpuPrescriptionLinGetWithHttpInfo($geom, $partition);
        return $response;
    }

    /**
     * Operation gpuPrescriptionLinGetWithHttpInfo
     *
     * Récupération des prescriptions linéaires d’un document d’urbanisme
     *
     * @param  string $geom Géométrie GeoJSON utilisée pour la recherche (optional)
     * @param  string $partition Partition GPU du document au format &lt;DU/PSMV&gt;_&lt;INSEE/SIREN&gt; (optional)
     *
     * @throws \ApiGouv\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \ApiGouv\Client\Model\FeatureCollection, HTTP status code, HTTP response headers (array of strings)
     */
    public function gpuPrescriptionLinGetWithHttpInfo($geom = null, $partition = null)
    {
        $returnType = '\ApiGouv\Client\Model\FeatureCollection';
        $request = $this->gpuPrescriptionLinGetRequest($geom, $partition);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\ApiGouv\Client\Model\FeatureCollection',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation gpuPrescriptionLinGetAsync
     *
     * Récupération des prescriptions linéaires d’un document d’urbanisme
     *
     * @param  string $geom Géométrie GeoJSON utilisée pour la recherche (optional)
     * @param  string $partition Partition GPU du document au format &lt;DU/PSMV&gt;_&lt;INSEE/SIREN&gt; (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function gpuPrescriptionLinGetAsync($geom = null, $partition = null)
    {
        return $this->gpuPrescriptionLinGetAsyncWithHttpInfo($geom, $partition)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation gpuPrescriptionLinGetAsyncWithHttpInfo
     *
     * Récupération des prescriptions linéaires d’un document d’urbanisme
     *
     * @param  string $geom Géométrie GeoJSON utilisée pour la recherche (optional)
     * @param  string $partition Partition GPU du document au format &lt;DU/PSMV&gt;_&lt;INSEE/SIREN&gt; (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function gpuPrescriptionLinGetAsyncWithHttpInfo($geom = null, $partition = null)
    {
        $returnType = '\ApiGouv\Client\Model\FeatureCollection';
        $request = $this->gpuPrescriptionLinGetRequest($geom, $partition);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'gpuPrescriptionLinGet'
     *
     * @param  string $geom Géométrie GeoJSON utilisée pour la recherche (optional)
     * @param  string $partition Partition GPU du document au format &lt;DU/PSMV&gt;_&lt;INSEE/SIREN&gt; (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function gpuPrescriptionLinGetRequest($geom = null, $partition = null)
    {

        $resourcePath = '/gpu/prescription-lin';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        if ($geom !== null) {
            $queryParams['geom'] = ObjectSerializer::toQueryValue($geom);
        }
        // query params
        if ($partition !== null) {
            $queryParams['partition'] = ObjectSerializer::toQueryValue($partition);
        }


        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                []
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            
            if($headers['Content-Type'] === 'application/json') {
                // \stdClass has no __toString(), so we should encode it manually
                if ($httpBody instanceof \stdClass) {
                    $httpBody = \GuzzleHttp\json_encode($httpBody);
                }
                // array has no __toString(), so we should encode it manually
                if(is_array($httpBody)) {
                    $httpBody = \GuzzleHttp\json_encode(ObjectSerializer::sanitizeForSerialization($httpBody));
                }
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\Query::build($formParams);
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\Query::build($queryParams);
        return new Request(
            'GET',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation gpuPrescriptionPctGet
     *
     * Récupération des prescriptions ponctuelles d’un document d’urbanisme
     *
     * @param  string $geom Géométrie GeoJSON utilisée pour la recherche (optional)
     * @param  string $partition Partition GPU du document au format &lt;DU/PSMV&gt;_&lt;INSEE/SIREN&gt; (optional)
     *
     * @throws \ApiGouv\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \ApiGouv\Client\Model\FeatureCollection
     */
    public function gpuPrescriptionPctGet($geom = null, $partition = null)
    {
        list($response) = $this->gpuPrescriptionPctGetWithHttpInfo($geom, $partition);
        return $response;
    }

    /**
     * Operation gpuPrescriptionPctGetWithHttpInfo
     *
     * Récupération des prescriptions ponctuelles d’un document d’urbanisme
     *
     * @param  string $geom Géométrie GeoJSON utilisée pour la recherche (optional)
     * @param  string $partition Partition GPU du document au format &lt;DU/PSMV&gt;_&lt;INSEE/SIREN&gt; (optional)
     *
     * @throws \ApiGouv\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \ApiGouv\Client\Model\FeatureCollection, HTTP status code, HTTP response headers (array of strings)
     */
    public function gpuPrescriptionPctGetWithHttpInfo($geom = null, $partition = null)
    {
        $returnType = '\ApiGouv\Client\Model\FeatureCollection';
        $request = $this->gpuPrescriptionPctGetRequest($geom, $partition);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\ApiGouv\Client\Model\FeatureCollection',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation gpuPrescriptionPctGetAsync
     *
     * Récupération des prescriptions ponctuelles d’un document d’urbanisme
     *
     * @param  string $geom Géométrie GeoJSON utilisée pour la recherche (optional)
     * @param  string $partition Partition GPU du document au format &lt;DU/PSMV&gt;_&lt;INSEE/SIREN&gt; (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function gpuPrescriptionPctGetAsync($geom = null, $partition = null)
    {
        return $this->gpuPrescriptionPctGetAsyncWithHttpInfo($geom, $partition)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation gpuPrescriptionPctGetAsyncWithHttpInfo
     *
     * Récupération des prescriptions ponctuelles d’un document d’urbanisme
     *
     * @param  string $geom Géométrie GeoJSON utilisée pour la recherche (optional)
     * @param  string $partition Partition GPU du document au format &lt;DU/PSMV&gt;_&lt;INSEE/SIREN&gt; (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function gpuPrescriptionPctGetAsyncWithHttpInfo($geom = null, $partition = null)
    {
        $returnType = '\ApiGouv\Client\Model\FeatureCollection';
        $request = $this->gpuPrescriptionPctGetRequest($geom, $partition);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'gpuPrescriptionPctGet'
     *
     * @param  string $geom Géométrie GeoJSON utilisée pour la recherche (optional)
     * @param  string $partition Partition GPU du document au format &lt;DU/PSMV&gt;_&lt;INSEE/SIREN&gt; (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function gpuPrescriptionPctGetRequest($geom = null, $partition = null)
    {

        $resourcePath = '/gpu/prescription-pct';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        if ($geom !== null) {
            $queryParams['geom'] = ObjectSerializer::toQueryValue($geom);
        }
        // query params
        if ($partition !== null) {
            $queryParams['partition'] = ObjectSerializer::toQueryValue($partition);
        }


        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                []
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            
            if($headers['Content-Type'] === 'application/json') {
                // \stdClass has no __toString(), so we should encode it manually
                if ($httpBody instanceof \stdClass) {
                    $httpBody = \GuzzleHttp\json_encode($httpBody);
                }
                // array has no __toString(), so we should encode it manually
                if(is_array($httpBody)) {
                    $httpBody = \GuzzleHttp\json_encode(ObjectSerializer::sanitizeForSerialization($httpBody));
                }
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\Query::build($formParams);
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\Query::build($queryParams);
        return new Request(
            'GET',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation gpuPrescriptionSurfGet
     *
     * Récupération des prescriptions surfaciques d’un document d’urbanisme
     *
     * @param  string $geom Géométrie GeoJSON utilisée pour la recherche (optional)
     * @param  string $partition Partition GPU du document au format &lt;DU/PSMV&gt;_&lt;INSEE/SIREN&gt; (optional)
     *
     * @throws \ApiGouv\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \ApiGouv\Client\Model\FeatureCollection
     */
    public function gpuPrescriptionSurfGet($geom = null, $partition = null)
    {
        list($response) = $this->gpuPrescriptionSurfGetWithHttpInfo($geom, $partition);
        return $response;
    }

    /**
     * Operation gpuPrescriptionSurfGetWithHttpInfo
     *
     * Récupération des prescriptions surfaciques d’un document d’urbanisme
     *
     * @param  string $geom Géométrie GeoJSON utilisée pour la recherche (optional)
     * @param  string $partition Partition GPU du document au format &lt;DU/PSMV&gt;_&lt;INSEE/SIREN&gt; (optional)
     *
     * @throws \ApiGouv\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \ApiGouv\Client\Model\FeatureCollection, HTTP status code, HTTP response headers (array of strings)
     */
    public function gpuPrescriptionSurfGetWithHttpInfo($geom = null, $partition = null)
    {
        $returnType = '\ApiGouv\Client\Model\FeatureCollection';
        $request = $this->gpuPrescriptionSurfGetRequest($geom, $partition);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\ApiGouv\Client\Model\FeatureCollection',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation gpuPrescriptionSurfGetAsync
     *
     * Récupération des prescriptions surfaciques d’un document d’urbanisme
     *
     * @param  string $geom Géométrie GeoJSON utilisée pour la recherche (optional)
     * @param  string $partition Partition GPU du document au format &lt;DU/PSMV&gt;_&lt;INSEE/SIREN&gt; (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function gpuPrescriptionSurfGetAsync($geom = null, $partition = null)
    {
        return $this->gpuPrescriptionSurfGetAsyncWithHttpInfo($geom, $partition)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation gpuPrescriptionSurfGetAsyncWithHttpInfo
     *
     * Récupération des prescriptions surfaciques d’un document d’urbanisme
     *
     * @param  string $geom Géométrie GeoJSON utilisée pour la recherche (optional)
     * @param  string $partition Partition GPU du document au format &lt;DU/PSMV&gt;_&lt;INSEE/SIREN&gt; (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function gpuPrescriptionSurfGetAsyncWithHttpInfo($geom = null, $partition = null)
    {
        $returnType = '\ApiGouv\Client\Model\FeatureCollection';
        $request = $this->gpuPrescriptionSurfGetRequest($geom, $partition);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'gpuPrescriptionSurfGet'
     *
     * @param  string $geom Géométrie GeoJSON utilisée pour la recherche (optional)
     * @param  string $partition Partition GPU du document au format &lt;DU/PSMV&gt;_&lt;INSEE/SIREN&gt; (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function gpuPrescriptionSurfGetRequest($geom = null, $partition = null)
    {

        $resourcePath = '/gpu/prescription-surf';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        if ($geom !== null) {
            $queryParams['geom'] = ObjectSerializer::toQueryValue($geom);
        }
        // query params
        if ($partition !== null) {
            $queryParams['partition'] = ObjectSerializer::toQueryValue($partition);
        }


        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                []
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            
            if($headers['Content-Type'] === 'application/json') {
                // \stdClass has no __toString(), so we should encode it manually
                if ($httpBody instanceof \stdClass) {
                    $httpBody = \GuzzleHttp\json_encode($httpBody);
                }
                // array has no __toString(), so we should encode it manually
                if(is_array($httpBody)) {
                    $httpBody = \GuzzleHttp\json_encode(ObjectSerializer::sanitizeForSerialization($httpBody));
                }
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\Query::build($formParams);
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\Query::build($queryParams);
        return new Request(
            'GET',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation gpuSecteurCcGet
     *
     * Récupération des secteurs d’une carte communale
     *
     * @param  string $geom Géométrie GeoJSON utilisée pour la recherche (optional)
     * @param  string $partition Partition GPU du document au format &lt;DU/PSMV&gt;_&lt;INSEE/SIREN&gt; (optional)
     *
     * @throws \ApiGouv\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \ApiGouv\Client\Model\FeatureCollection
     */
    public function gpuSecteurCcGet($geom = null, $partition = null)
    {
        list($response) = $this->gpuSecteurCcGetWithHttpInfo($geom, $partition);
        return $response;
    }

    /**
     * Operation gpuSecteurCcGetWithHttpInfo
     *
     * Récupération des secteurs d’une carte communale
     *
     * @param  string $geom Géométrie GeoJSON utilisée pour la recherche (optional)
     * @param  string $partition Partition GPU du document au format &lt;DU/PSMV&gt;_&lt;INSEE/SIREN&gt; (optional)
     *
     * @throws \ApiGouv\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \ApiGouv\Client\Model\FeatureCollection, HTTP status code, HTTP response headers (array of strings)
     */
    public function gpuSecteurCcGetWithHttpInfo($geom = null, $partition = null)
    {
        $returnType = '\ApiGouv\Client\Model\FeatureCollection';
        $request = $this->gpuSecteurCcGetRequest($geom, $partition);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\ApiGouv\Client\Model\FeatureCollection',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation gpuSecteurCcGetAsync
     *
     * Récupération des secteurs d’une carte communale
     *
     * @param  string $geom Géométrie GeoJSON utilisée pour la recherche (optional)
     * @param  string $partition Partition GPU du document au format &lt;DU/PSMV&gt;_&lt;INSEE/SIREN&gt; (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function gpuSecteurCcGetAsync($geom = null, $partition = null)
    {
        return $this->gpuSecteurCcGetAsyncWithHttpInfo($geom, $partition)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation gpuSecteurCcGetAsyncWithHttpInfo
     *
     * Récupération des secteurs d’une carte communale
     *
     * @param  string $geom Géométrie GeoJSON utilisée pour la recherche (optional)
     * @param  string $partition Partition GPU du document au format &lt;DU/PSMV&gt;_&lt;INSEE/SIREN&gt; (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function gpuSecteurCcGetAsyncWithHttpInfo($geom = null, $partition = null)
    {
        $returnType = '\ApiGouv\Client\Model\FeatureCollection';
        $request = $this->gpuSecteurCcGetRequest($geom, $partition);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'gpuSecteurCcGet'
     *
     * @param  string $geom Géométrie GeoJSON utilisée pour la recherche (optional)
     * @param  string $partition Partition GPU du document au format &lt;DU/PSMV&gt;_&lt;INSEE/SIREN&gt; (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function gpuSecteurCcGetRequest($geom = null, $partition = null)
    {

        $resourcePath = '/gpu/secteur-cc';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        if ($geom !== null) {
            $queryParams['geom'] = ObjectSerializer::toQueryValue($geom);
        }
        // query params
        if ($partition !== null) {
            $queryParams['partition'] = ObjectSerializer::toQueryValue($partition);
        }


        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                []
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            
            if($headers['Content-Type'] === 'application/json') {
                // \stdClass has no __toString(), so we should encode it manually
                if ($httpBody instanceof \stdClass) {
                    $httpBody = \GuzzleHttp\json_encode($httpBody);
                }
                // array has no __toString(), so we should encode it manually
                if(is_array($httpBody)) {
                    $httpBody = \GuzzleHttp\json_encode(ObjectSerializer::sanitizeForSerialization($httpBody));
                }
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\Query::build($formParams);
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\Query::build($queryParams);
        return new Request(
            'GET',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation gpuZoneUrbaGet
     *
     * Récupération des zonages d’un document d’urbanisme
     *
     * @param  string $geom Géométrie GeoJSON utilisée pour la recherche (optional)
     * @param  string $partition Partition GPU du document au format &lt;DU/PSMV&gt;_&lt;INSEE/SIREN&gt; (optional)
     *
     * @throws \ApiGouv\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \ApiGouv\Client\Model\FeatureCollection
     */
    public function gpuZoneUrbaGet($geom = null, $partition = null)
    {
        list($response) = $this->gpuZoneUrbaGetWithHttpInfo($geom, $partition);
        return $response;
    }

    /**
     * Operation gpuZoneUrbaGetWithHttpInfo
     *
     * Récupération des zonages d’un document d’urbanisme
     *
     * @param  string $geom Géométrie GeoJSON utilisée pour la recherche (optional)
     * @param  string $partition Partition GPU du document au format &lt;DU/PSMV&gt;_&lt;INSEE/SIREN&gt; (optional)
     *
     * @throws \ApiGouv\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \ApiGouv\Client\Model\FeatureCollection, HTTP status code, HTTP response headers (array of strings)
     */
    public function gpuZoneUrbaGetWithHttpInfo($geom = null, $partition = null)
    {
        $returnType = '\ApiGouv\Client\Model\FeatureCollection';
        $request = $this->gpuZoneUrbaGetRequest($geom, $partition);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\ApiGouv\Client\Model\FeatureCollection',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation gpuZoneUrbaGetAsync
     *
     * Récupération des zonages d’un document d’urbanisme
     *
     * @param  string $geom Géométrie GeoJSON utilisée pour la recherche (optional)
     * @param  string $partition Partition GPU du document au format &lt;DU/PSMV&gt;_&lt;INSEE/SIREN&gt; (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function gpuZoneUrbaGetAsync($geom = null, $partition = null)
    {
        return $this->gpuZoneUrbaGetAsyncWithHttpInfo($geom, $partition)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation gpuZoneUrbaGetAsyncWithHttpInfo
     *
     * Récupération des zonages d’un document d’urbanisme
     *
     * @param  string $geom Géométrie GeoJSON utilisée pour la recherche (optional)
     * @param  string $partition Partition GPU du document au format &lt;DU/PSMV&gt;_&lt;INSEE/SIREN&gt; (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function gpuZoneUrbaGetAsyncWithHttpInfo($geom = null, $partition = null)
    {
        $returnType = '\ApiGouv\Client\Model\FeatureCollection';
        $request = $this->gpuZoneUrbaGetRequest($geom, $partition);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'gpuZoneUrbaGet'
     *
     * @param  string $geom Géométrie GeoJSON utilisée pour la recherche (optional)
     * @param  string $partition Partition GPU du document au format &lt;DU/PSMV&gt;_&lt;INSEE/SIREN&gt; (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function gpuZoneUrbaGetRequest($geom = null, $partition = null)
    {

        $resourcePath = '/gpu/zone-urba';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        if ($geom !== null) {
            $queryParams['geom'] = ObjectSerializer::toQueryValue($geom);
        }
        // query params
        if ($partition !== null) {
            $queryParams['partition'] = ObjectSerializer::toQueryValue($partition);
        }


        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                []
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            
            if($headers['Content-Type'] === 'application/json') {
                // \stdClass has no __toString(), so we should encode it manually
                if ($httpBody instanceof \stdClass) {
                    $httpBody = \GuzzleHttp\json_encode($httpBody);
                }
                // array has no __toString(), so we should encode it manually
                if(is_array($httpBody)) {
                    $httpBody = \GuzzleHttp\json_encode(ObjectSerializer::sanitizeForSerialization($httpBody));
                }
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\Query::build($formParams);
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\Query::build($queryParams);
        return new Request(
            'GET',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Create http client option
     *
     * @throws \RuntimeException on file opening failure
     * @return array of http client options
     */
    protected function createHttpClientOption()
    {
        $options = [];
        if ($this->config->getDebug()) {
            $options[RequestOptions::DEBUG] = fopen($this->config->getDebugFile(), 'a');
            if (!$options[RequestOptions::DEBUG]) {
                throw new \RuntimeException('Failed to open the debug file: ' . $this->config->getDebugFile());
            }
        }

        return $options;
    }
}
